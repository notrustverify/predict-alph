Contract Game(
   predictTemplateId: ByteVec,
   punterTemplateId: ByteVec,
   roundTemplateId: ByteVec,
   mut operator: Address,
   mut gameCounter: U256
){

   event BetBull(from: Address, epoch: U256, amount: U256, up: Bool)
   event BetBear(from: Address, epoch: U256, amount: U256, up: Bool)
   event RoundEnded(epoch: U256, price: U256)
   event RoundStarted(epoch: U256, price: U256)
   event Claimed(addressToClaim: Address, from: Address, epochs: ByteVec)
   event GameCreated(contractId: ByteVec, gameId: U256)


   enum ErrorCodes {
      InvalidCaller = 300
      GameNotExists = 301
      GameAlreadyExists = 302
   }

   enum SubContractTypes {
      Game = #03
   }

   
   fn getGame(gameId: U256) -> (Predict) {
      let gameContractId = subContractId!(SubContractTypes.Game ++ u256To4Byte!(gameId))
      assert!(contractExists!(gameContractId), ErrorCodes.GameNotExists)
    
      return Predict(gameContractId)
   }


   pub fn getActualGameId() -> (U256) {
      return gameCounter
   }

   @using(checkExternalCaller = true, updateFields = true, preapprovedAssets = true)
   pub fn createGame(feesBasisPts: U256, repeatEvery: U256, claimedByAnyoneDelay: U256, title: ByteVec) -> (){
      let caller = callerAddress!()

      checkCaller!(caller == operator, ErrorCodes.InvalidCaller)

      let (encodedImmFields, encodedMutFields) = Predict.encodeFields!(selfContract!(), punterTemplateId, roundTemplateId, title, 0,operator,feesBasisPts, repeatEvery, claimedByAnyoneDelay, 0)

      let gameContractPath = SubContractTypes.Game ++ u256To4Byte!(gameCounter)
      assert!(!contractExists!(subContractId!(gameContractPath)), ErrorCodes.GameAlreadyExists)

      let contractId = copyCreateSubContract!{caller -> ALPH: 1 alph}(gameContractPath, predictTemplateId, encodedImmFields, encodedMutFields)

      emit GameCreated(contractId, gameCounter)
      gameCounter = gameCounter + 1

   }

   pub fn destroyPredict(gameId: U256) -> (){
      let caller = callerAddress!()

      checkCaller!(caller == operator, ErrorCodes.InvalidCaller)
      
      let predict = getGame(gameId)
      predict.destroy()

   }

   pub fn destroyRound(gameId: U256, epochArray: ByteVec) -> (){
      let caller = callerAddress!()

      checkCaller!(caller == operator, ErrorCodes.InvalidCaller)
      
      let predict = getGame(gameId)
      predict.destroyRound(epochArray)

   }


   @using(preapprovedAssets = true, checkExternalCaller = true)
   pub fn startRound(gameId: U256, price: U256) -> (){
      let predict = getGame(gameId)
      let caller = callerAddress!()

      checkCaller!(caller == operator, ErrorCodes.InvalidCaller)

      let epoch = predict.startRound{caller -> ALPH: 1 alph}(caller, price)

      emit RoundStarted(epoch, price)
   }

   @using(preapprovedAssets = true, checkExternalCaller = true)
   pub fn endRound(gameId: U256, actualPrice: U256, immediatelyStart: Bool) -> (){
      let predict = getGame(gameId)
      let caller = callerAddress!()

      checkCaller!(caller == operator, ErrorCodes.InvalidCaller)


      let epoch = predict.endRound{caller -> ALPH: 1 alph}(caller, actualPrice, immediatelyStart)

      emit RoundEnded(epoch, actualPrice)

   }

   @using(preapprovedAssets = true, updateFields = false, checkExternalCaller = false)
   pub fn bid(gameId: U256, amount: U256, up: Bool) ->(){
      let predict = getGame(gameId)
      let caller = callerAddress!()

      let epoch = predict.bid{caller -> ALPH: amount}(amount, up, caller)

      if (up){
         emit BetBull(caller, epoch, amount, up)
      } else {
         emit BetBear(caller, epoch, amount, up)
      }
      
   }

   @using(checkExternalCaller = false)
   pub fn withdraw(gameId: U256, arrayEpochIn: ByteVec, addressToClaim: Address) -> (){
      let predict = getGame(gameId)
      let caller = callerAddress!()

      predict.withdraw(caller, arrayEpochIn, addressToClaim)
      
      emit Claimed(addressToClaim, caller, arrayEpochIn)
   }

   @using(preapprovedAssets = true, checkExternalCaller = false)
   pub fn boostRound(gameId: U256, amount: U256, epochToBoost: U256) -> (){
      let predict = getGame(gameId)
      let caller = callerAddress!()

      predict.boostRound{caller -> ALPH: amount}(caller, amount, epochToBoost)
      
   }

   @using(updateFields = true, checkExternalCaller = false)
   pub fn setNewOperator(newOperator: Address) -> (){
      checkCaller!(callerAddress!() == operator, ErrorCodes.InvalidCaller)
      operator = newOperator
   

   }
}